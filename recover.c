#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>
#include <string.h>

#include "recover.h"

#pragma pack(push,1)
typedef struct BootEntry {
    unsigned char BS_jmpBoot[3];
    unsigned char BS_OEMName[8];
    unsigned short BPB_BytsPerSec;
    unsigned char BPB_SecPerClus;
    unsigned short BPB_RsvdSecCnt;
    unsigned char BPB_NumFATs;
    unsigned short BPB_RootEntCnt;
    unsigned short BPB_TotSec16;
    unsigned char BPB_Media;
    unsigned short BPB_FATSz16;
    unsigned short BPB_SecPerTrk;
    unsigned short BPB_NumHeads;
    unsigned int BPB_HiddSec;
    unsigned int BPB_TotSec32;
    unsigned int BPB_FATSz32;
    unsigned short BPB_ExtFlags;
    unsigned short BPB_FSVer;
    unsigned int BPB_RootClus;
    unsigned short BPB_FSInfo;
    unsigned short BPB_BkBootSec;
    unsigned char BPB_Reserved[12];
    unsigned char BS_DrvNum;
    unsigned char BS_Reserved1;
    unsigned char BS_BootSig;
    unsigned int BS_VolID;
    unsigned char BS_VolLab[11];
    unsigned char BS_FilSysType[8];
} BootEntry;
#pragma pack(pop)
             
int recover(int argc, char **argv){

    // Milestone 1: validate usage
    if(validate_usage(argc,argv) != 0){
        return 1;
    }



    return 0;
}

int validate_usage(int argc, char **argv){
    char *error_message = 
    "Usage: ./nyufile disk <options>\n"
    "  -i                     Print the file system information.\n"
    "  -l                     List the root directory.\n"
    "  -r filename [-s sha1]  Recover a contiguous file.\n"
    "  -R filename -s sha1    Recover a possibly non-contiguous file.\n";

    if(argc < 2){
        printf("%s", error_message);
        return 1;
    }

    if (access(argv[1], F_OK) == -1) {
        printf("%s", error_message);
        return 1;
    }

    int option;
    int i_flag = 0, l_flag = 0, r_flag = 0, R_flag = 0, s_flag = 0;
    char *filename = NULL;
    char *sha1 = NULL;

    optind = 2;

    // Set opterr to 0 to disable default error messages generated by getopt()
    opterr = 0;

    while ((option = getopt(argc, argv, "ilr:R:s:")) != -1) {
        switch(option){
            case 'i':
                i_flag = 1;
                break;          
            case 'l':
                printf("option l\n");
                l_flag = 1;
                break;
            case 'r':
                if(optarg == NULL){
                    printf("%s", error_message);
                    return 1;
                }
                r_flag = 1;
                filename = optarg;
                break;
            case 's':
                if(optarg == NULL){
                    printf("%s", error_message);
                    return 1;
                }
                s_flag = 1;
                sha1 = optarg;
                break;
            case 'R':
                if(optarg == NULL){
                    printf("%s", error_message);
                    return 1;
                }
                R_flag = 1;
                filename = optarg;
                break;
            default:
                printf("%s", error_message);
                return 1;
        }
    }

    if(i_flag){
        // Print the file system information.
        return printFSInfo(argv);
    }else if(l_flag){
        // Print List the root directory.
        printf("l flag is on\n");
    }else if(r_flag && !s_flag){
        // Recover a contiguous file without shal
        printf("Recover a contiguous file without shal\n");
    }else if(r_flag && s_flag){
        // Recover a contiguous file shal
        printf("Recover a contiguous file with shal\n");
    }else if(R_flag && s_flag){
        // Recover a possibly non-contiguous file.
        printf("Recover a possibly non-contiguous file.\n");
    }else if(R_flag && !s_flag){
        printf("%s", error_message);
        return 1;
    }

    return 0;
}

int printFSInfo(char **argv){
    // Open file
    int fd = open(argv[1], O_RDONLY);
    if(fd < 0){
        perror("Error opening file");
        return 1;
    }

    // Get file size
    struct stat st;
    if (fstat(fd, &st) == -1){
        perror("Error opening file");
        return 1;
    }
    // Map file into memory
    char *data = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
    if (data == MAP_FAILED) {
            perror("Error mapping file");
            close(fd);
            return 1;
        }
    BootEntry *bs = (BootEntry *)data;
    printf("Number of FATs = %d\n", bs->BPB_NumFATs);
    printf("Number of bytes per sector = %d\n", bs->BPB_BytsPerSec);
    printf("Number of sectors per cluster = %d\n", bs->BPB_SecPerClus);
    printf("Number of reserved sectors = %d\n", bs->BPB_RsvdSecCnt);

    munmap(data, st.st_size);
    close(fd);

    return 0;
}
